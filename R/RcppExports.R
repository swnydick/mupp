# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

start_profiler <- function(str) {
    .Call(`_mupp_start_profiler`, str)
}

stop_profiler <- function() {
    .Call(`_mupp_stop_profiler`)
}

#' Find All Permutations of Consecutive Integers
#'
#' Given an consecutive integer vector of length n, find all permutations of
#' that vector.
#'
#' @param n an integer greater than 0
#' @param init an integer indicating the initial starting value for the set
#'        of integers included in the permutation. See Details.
#'
#' @return A matrix of size n! x n, where each row is a unique permutation
#'
#' @details \code{init} is useful for indexing C vs R code. If \code{init = 0},
#'          then the indices will work with 0 indexed languages, such as C or
#'          Python. If \code{init = 1}, then the indices will work with 1 indexed
#'          languages, such as R.
#'
#' @author Steven Nydick, \email{steven.nydick@@kornferry.com}
#'
#' @export
find_all_permutations <- function(n, init = 0L) {
    .Call(`_mupp_find_all_permutations`, n, init)
}

#' Find Column for Cross-Product
#'
#' Given two dimension and the total number of dimensions, find the column
#' indexing the appropriate cross-product.
#'
#' @param dim1 the first dimension
#' @param dim2 the second dimension
#' @param n_dims the total number of dimensions
#' @param init an integer indicating the initial starting value for the set
#'        of integers included in the permutation. See Details.
#'
#' @return The index of the cross-product column.
#'
#' @details \code{init} is useful for indexing C vs R code. If \code{init = 0},
#'          then the indices will work with 0 indexed languages, such as C or
#'          Python. If \code{init = 1}, then the indices will work with 1 indexed
#'          languages, such as R.
#'
#'          This function assumes that the first n_dims columns are the dims,
#'          the next n_dims - 1 columns are the cross-products of dimension 1 with
#'          the remaining dims, the next n_dims - 2 columns are the cross-products
#'          of dimension 2 with the remaining dims > 2, etc.
#'
#' @seealso \code{\link{find_crossprod_dims}}
#'
#' @author Steven Nydick, \email{steven.nydick@@kornferry.com}
#'
#' @export
find_crossprod_column <- function(dim1, dim2, n_dims, init = 0L) {
    .Call(`_mupp_find_crossprod_column`, dim1, dim2, n_dims, init)
}

#' Find Dimensions given Cross-Product Column
#'
#' Given the column indexing the appropriate cross-product and the total number
#' of dimensions, find the two dimensions leading to the cross-product.
#'
#' @param dim12 the column of the matrix or data.frame
#' @param n_dims the total number of dimensions
#' @param init an integer indicating the initial starting value for the set
#'        of integers included in the permutation. See Details.
#'
#' @return A vector/array indicating the cross-product dimensions.
#'
#' @details \code{init} is useful for indexing C vs R code. If \code{init = 0},
#'          then the indices will work with 0 indexed languages, such as C or
#'          Python. If \code{init = 1}, then the indices will work with 1 indexed
#'          languages, such as R.
#'
#'          This function assumes that the first n_dims columns are the dims,
#'          the next n_dims - 1 columns are the cross-products of dimension 1 with
#'          the remaining dims, the next n_dims - 2 columns are the cross-products
#'          of dimension 2 with the remaining dims > 2, etc.
#' @seealso \code{\link{find_crossprod_column}}
#'
#' @author Steven Nydick, \email{steven.nydick@@kornferry.com}
#'
#' @export
find_crossprod_dims <- function(dim12, n_dims, init = 0L) {
    .Call(`_mupp_find_crossprod_dims`, dim12, n_dims, init)
}

p_mupp_rank_impl <- function(thetas, params, dims = 0L, picked_order_id = 0L) {
    .Call(`_mupp_p_mupp_rank_impl`, thetas, params, dims, picked_order_id)
}

pder1_mupp_rank_impl <- function(thetas, params, dims = 0L, picked_order_id = 0L) {
    .Call(`_mupp_pder1_mupp_rank_impl`, thetas, params, dims, picked_order_id)
}

pder2_mupp_rank_impl <- function(thetas, params, dims = 0L, picked_order_id = 0L) {
    .Call(`_mupp_pder2_mupp_rank_impl`, thetas, params, dims, picked_order_id)
}

loglik_mupp_rank_impl <- function(thetas, params, items, picked_orders) {
    .Call(`_mupp_loglik_mupp_rank_impl`, thetas, params, items, picked_orders)
}

lder1_mupp_rank_impl <- function(thetas, params, items, picked_orders) {
    .Call(`_mupp_lder1_mupp_rank_impl`, thetas, params, items, picked_orders)
}

lder2_mupp_rank_impl <- function(thetas, params, items, picked_orders) {
    .Call(`_mupp_lder2_mupp_rank_impl`, thetas, params, items, picked_orders)
}

