# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

start_profiler <- function(str) {
    .Call(`_mupp_start_profiler`, str)
}

stop_profiler <- function() {
    .Call(`_mupp_stop_profiler`)
}

#' Find All Permutations of Consecutive Integers
#'
#' Given an consecutive integer vector of length n, find all permutations of
#' that vector.
#'
#' @param n an integer greater than 0
#' @param init an integer indicating the initial starting value for the set
#'        of integers included in the permutation. See Details.
#'
#' @return A matrix of size n! x n, where each row is a unique permutation
#'
#' @details \code{init} is useful for indexing C vs R code. If \code{init = 0},
#'          then the indices will work with 0 indexed languages, such as C or
#'          Python. If \code{init = 1}, then the indices will work with 1 indexed
#'          languages, such as R.
#'
#' @author Steven Nydick, \email{steven.nydick@@kornferry.com}
#'
#' @export
find_all_permutations <- function(n, init = 0L) {
    .Call(`_mupp_find_all_permutations`, n, init)
}

q_ggum_all <- function(thetas, params) {
    .Call(`_mupp_q_ggum_all`, thetas, params)
}

pder1_theta_ggum_all <- function(thetas, params) {
    .Call(`_mupp_pder1_theta_ggum_all`, thetas, params)
}

p_mupp_rank_impl <- function(thetas, params, dims = NA_integer_, picked_order_id = NA_integer_) {
    .Call(`_mupp_p_mupp_rank_impl`, thetas, params, dims, picked_order_id)
}

loglik_mupp_rank_impl <- function(thetas, params, items, picked_orders) {
    .Call(`_mupp_loglik_mupp_rank_impl`, thetas, params, items, picked_orders)
}

